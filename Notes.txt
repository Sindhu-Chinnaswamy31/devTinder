
------------------------
session-3
------------------------

//create new project
terminal 
 - npm init

connect server express js
 - npm i express

to stop we can't use cntl+c every time so we are using nodemon, it will resrat the server when changes done.
 - sudo npm i -g nodemon (because we are isntaling global level thats why we are using -g and permission issue we are using sudo)
 - nodemon src/app.js insted of node src/app.js
 - added the scripts : nodemon src/app.js so we can use npm run start

* node modules : is a place when we install some packages and it get the code form internet and put it here
* package.json will also update when ever we did npm i install package
* dependencies : without that package project won't work properly ex : express for nodejs
* all dependencis store inside node_modules.
* package-lock.json : to lock the installed package version.

* the ^ (caret) symbol, which is the default for new dependencies and allows for both minor and patch updates while locking the major version. 
For example, ^1.2.3 would allow 1.3.0 or 1.4.0 but not 2.0.0.

* The ~ (tilde) symbol in package.json is used to specify a version range for a project's dependencies,
 indicating that the project can use any version of the package within the same minor version, allowing for patch updates. eg : ~1.2.3 allows 1.2.4, 1.2.5, etc

--------------------------
session - 4
--------------------------
app.use("/", (req, res) => {
    res.send("This is home page");
}); 
- it will override every thing, anything match after slash it will handle like if i run localhost:port/hello i will get thiso utput only.
- this handler not only handle / it will handle anything match start with /anything
- if i change order of execution it will work fine. 
example : 
app.use("/test", (req, res) => {
    res.send("heloo nodeJs server");
});
app.use("/hello", (req, res) => {
    res.send("heloo sindhu");
});
- order of the routes matter.

HTTP methods:

app.use : it will match all the HTTP method API calls to /test
app.use("/test", (req, res) => {
    res.send("heloo sindhu");
});

app.post : it will only handle POST to /user 
app.post("/user", (req, res) => {
    console.log(req);
    res.send(req);
});

app.get : it will only handle GET to /user 
app.get("/test", (req, res) => {
    res.send("heloo sindhu");
});

app.get("/a(b?)c", (req, res) => {
    res.send("Matches /abc or /ac");
});
? means the preceding character is optional
So /ab?c matches /ac or /abc. b? → “b is optional”
it won’t work in Express 5 without parentheses or escaping because path-to-regexp is stricter now
in Express 5.x, path-to-regexp v6 doesn’t allow regex-style groups like (b?) in plain strings anymore.

//get query params data
app.post("/queryParams", (req, res) => {
    res.send(req.query);
}); o/p => { "name": "sindhu" }

//http://localhost:8000/queryParams/107
app.post("/queryParams/:userId", (req, res) => {
    res.send(req.params);
}); o/p => { "userId": "107"}

//http://localhost:8000/queryParams/107/sindhu67ty
app.post("/queryParams/:userId/:password", (req, res) => {
    res.send(req.params);
});

o/p => { "userId": "107", "password": "sindhu67ty" }


--------------------------
session - 5
--------------------------
-> One request handler can have multple request handler inside 
ex :    app.use("/test", (req, res) => {
            res.send("router handler 1");
        }, (req, res) => {
            res.send("router handler 2");
        }, (req, res)=>{
            res.send("router handler 3");
        });
output : router handle 1

* if the first res is not return it will not go to next req it will simply load infinit loop.
* if we call next parameter it will print the next response, next is passed as third argument and we need to call that function next ()
// if we want to run multiple request handler
app.use("/test", (req, res, next) => {
    //res.send("router handler 1");
    next();
}, (req, res, next) => {
    // res.send("router handler 2");
    next()
}, (req, res)=>{
    res.send("router handler 3");
});

* we should never write like this it will give error.
* here we are getting error because we are sending response to client request already fulfilled,
so using this method is not a good idea
// if we want to run multiple request handler
app.use("/test", (req, res, next) => {
    next();  
    res.send("router handler 1");
}, (req, res, next) => {
    res.send("router handler 2");
    next()
}, (req, res)=>{
    res.send("router handler 3");
});

output : router handler 2

* it will directly go to next router it won't print the first router.
* if we call next() then only next router handler will call.
* if we are in last response we are not sending any response so we will get error Cannot GET /test.
* we are calling next() express expecting next route handler so it can't find it will throw error.
* we can also pass array of function. it will behave same.
app.use("/test", 
[(req, res, next) => {
    next(); //it will call next request handler
    res.send("router handler 1");
}, (req, res, next) => {
    res.send("router handler 2");
    next()
}], (req, res, next)=>{
    res.send("router handler 3");
    next();
}, (req, res, next)=>{
    res.send("router handler 4");
    next();
});

* wrap inside array doesn't do anything.


app.get("/hello", (req, res, next) => {
    //res.send("Hellooooooo sindhu");
    next();
});

app.get("/hello", (req, res, next) => {
    //res.send("Hellooooooo sindhu 2222222");
    next();
});

app.get("/hello", (req, res, next) => {
    //res.send("Hellooooooo sindhu 3333333");
    next();
});

o/p throw error : Cannot GET /hello
* over come this issue we are using middleware

* Middleware : a function that is accessible to the request, 
    response objects and the next middleware function. 
    It can execute any code, terminate the request-response cycle, 
    make needed changes in req and res objects, and detect errors.

* Route Handler : A single callback function can handle a route.

//Handle auth middleware for all request GET, POST, DELETE
app.use("/admin"); //app.all("/admin");

* Difference btw all and use (homework)

//Handle auth middleware for all request GET, POST, DELETE
app.use("/admin", (req, res, next) => {
    //Logic of checking if the request is authorized
    const token = req.query.token;//read post data
    const isAuthorised =  token === "sindhu";
    if(!isAuthorised){
        res.status(403).send("unauthorised");
    }else{
        next();
    }
}); //app.all("/admin");

app.get("/user", (req, res) => {
    res.send("Fetch user data");
});//here admin middleware wont call because it will not match /admin

app.get("/admin/getAllUserData", (req, res) => {
    res.send("Get all the data");
});

app.get("/admin/deleteUser", (req, res) => {
    res.send("User deleted successfully");
});

* Work with middleWare app.js
const {adminAuth, userAuth} = require("./middlewares/auth");
app.use("/admin", adminAuth);
app.use("/user", userAuth);

app.get("UserLogin", (req, res) => {
    res.send("Login page");
});

app.get("/userData", userAuth, (req, res) => {// either call middle ware like this or use app.use("/user/userData"........;
    res.send("Fetch user data");
});//here admin middleware wont call because it will not match /admin

app.get("/admin/getAllUserData", (req, res) => {
    res.send("Get all the data");
});

app.get("/admin/deleteUser", (req, res) => {
    res.send("User deleted successfully");
});

* Middleware/auth.js
const adminAuth = (req, res, next) => {
    const token = req.query.token;
    const isAuthorised =  token === "admin";
    if(!isAuthorised){
        res.status(403).send("unauthorised");
    }else{
        next();
    }
}

const userAuth = (req, res, next) => {
    const token = req.query.token;
    const isAuthorised =  token === "user";
    if(!isAuthorised){
        res.status(403).send("unauthorised");
    }else{
        next();
    }
}


module.exports = 
{
    adminAuth,
    userAuth
}

//db call and get user data
app.get("/getData", (req, res) => {
    throw new Error("Something went wrong");
});

app.get("/getDataError", (req, res) => {
    try{
        throw new Error("Something went wrong");
    }catch (error) {
        res.send(500).send("Something error");
    }
});

//error handling in the middleware
app.get("/getUserData", (err, req, res, next) => { // error should be first parameter, req, res, next
    if(err){
        //log your error
        res.status(500).send("Something went wrong");
    }
});


------------------------------
database_mongoose session - 6
------------------------------
* Cluster conncetion issue 
* mango db website change the IP address 49.207.203.144/32

* instal mongoose
npm install mongoose

* Create folder inside the src > config > database.js
const database = require("mongoose"); // returns a promise

const connectDB = async () => {
    await database.connect("mongodb+srv://sindhucswamy:WIDvHhmL38FR2VSS@cluster0.vf5zi2b.mongodb.net/devTinder");//if we not mention db name it will default take the cluster
}

connectDB()
    .then(() => console.log("Database connected"))
    .catch((err) => console.log(err));

* connect to our project 
const server = require("express");
require("./config/database");

const app = server();

app.listen(8000, () =>{
    console.log("Server is running on port 8000");
});

* First conenct the database then only connect server.

database.js
-------------
const database = require("mongoose"); // returns a promise

const connectDB = async () => {
    await database.connect("mongodb+srv://sindhucswamy:WIDvHhmL38FR2VSS@cluster0.vf5zi2b.mongodb.net/devTinder");
}

module.exports = connectDB;

App.js
--------------
const server = require("express");
const connectDB = require("./config/database");

const app = server();

connectDB()
    .then(() => {
        console.log("Database connected")
        app.listen(8000, () =>{
            console.log("Server is running on port 8000");
        });
    })
    .catch((err) => console.log(err));

* schema : identity for the collection document, ex : defining the table user, what can user have pawword, lastname, phonenumber.....
* Creating schema
 > src/models/user.js
 const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({ //schema for user collection
    firstName: {
        type: String,
        required: true
    },
    lastname: {
        type : String,
        required: false
    }
});

module.exports = mongoose.model("User", userSchema);

* POST method is best to create API

app.js //signup
------------
const server = require("express");
const connectDB = require("./config/database");
const app = server();
const UserModel = require("./models/user");
//crete a route / API
//Sign API
app.post("/signUp", async (req, res) => {
    const userObj = {
        firstName: "Sindhu",
        lastName: "Chinnaswamy",
        email: "sindhu@gmail.com",
        password: "sindhu@123",
        phoneNumber: "9876543210",
        gender: "female",
        age: 28,
        bio: "i am a software developer",
        status: "active"
    }

    //create a instance of user model
    const user = new UserModel(userObj);
    try{
        await user.save(); // instance of model
        res.send("User added succesfully!");
    }catch(err){
        console.log(err);
    }

});

connectDB()
    .then(() => {
        console.log("Database connected")
        app.listen(8000, () =>{
            console.log("Server is running on port 8000");
        });
    })
    .catch((err) => console.log(err));


* _id : is a unique id which is given by mongoo
* __v : a version key added by Mongoose to documents in MongoDB.


------------------------------
diving into api session - 7
------------------------------
HW : Difference bwt json and javscript objects
json takes key value as string but in javascript object key is not a string.
json can't take comma at the end but json object will take

*  console.log(req.body); => give us a undefind because we sent json data, 
the data sent in json formate and our server is not bale to read that json data to read that we need middleware.
* That middleware convert json data into javascript object.
* expressJSON middleware : app.use(express.json()) // this will convert the data

*Difference bwt findOne and find
findOne -> give you one user
find -> will give you all the matched user in array
{returnDocument: "before"} in console it fetch the data before data and console if we put after it will update and return the document after update.

------------------------------
data_sanitozation session - 8
------------------------------
* Schema Types :

String
Number
Date
Buffer
Boolean
Mixed
ObjectId
Array
Decimal128
Map
Schema
UUID
BigInt
Double
Int32

* All Schema Types
- required: boolean or function, if true adds a required validator for this property
- default: Any or function, sets a default value for the path. If the value is a function, the return value of the function is used as the default.
- select: boolean, specifies default projections for queries
- validate: function, adds a validator function for this property
- get: function, defines a custom getter for this property using Object.defineProperty().
- set: function, defines a custom setter for this property using Object.defineProperty().
- alias: string, mongoose >= 4.10.0 only. Defines a virtual with the given name that gets/sets this path.
immutable: boolean, defines path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has isNew: true.
- transform: function, Mongoose calls this function when you call Document#toJSON() function, including when you JSON.stringify() a document.

* String
- lowercase: boolean, whether to always call .toLowerCase() on the value
- uppercase: boolean, whether to always call .toUpperCase() on the value
- trim: boolean, whether to always call .trim() on the value
- match: RegExp, creates a validator that checks if the value matches the given regular expression
- enum: Array, creates a validator that checks if the value is in the given array.
- - minLength: Number, creates a validator that checks if the value length is not less than the given number
- maxLength: Number, creates a validator that checks if the value length is not greater than the given number
- populate: Object, sets default populate options

* Number
- min: Number, creates a validator that checks if the value is greater than or equal to the given minimum.
- max: Number, creates a validator that checks if the value is less than or equal to the given maximum.
- enum: Array, creates a validator that checks if the value is strictly equal to one of the values in the given array.
- populate: Object, sets default populate options

* Date
- min: Date, creates a validator that checks if the value is greater than or equal to the given minimum.
- max: Date, creates a validator that checks if the value is less than or equal to the given maximum.
- expires: Number or String, creates a TTL index with the value expressed in seconds.

* ObjectId
- populate: Object, sets default populate options

* validate will only work for new data not for existing data.
* we need to update the validation for patch request also.
        const user = await UserModel.findByIdAndUpdate({_id: UserId}, body, {returnDocument: "before", runValidators: true});


* API level validation

* npm i validator : we can use this library 

* never trust req.body

-------------------------------
encryption password session - 9
-------------------------------
* validating data
* Encryp the password and then store this into database
* encrypt the passwrod use bcrypt
npm install bcrypt

--------------------------------------
authentication jwt token session - 10
--------------------------------------
jwt token : json web token
cookies :
session : 
* when ever user is loggin in server create token and attached the cookie send back, 
now that cookie will be stored by browser any request that comming up next that cookie will be sent along,
and we will validate again  and then do anything we want to do.
* cookie-parser : 
npm i cookie-parser

*json web token - jwt 
npm i jsonwebtoken

* expiresIn: "1d" -> here we can expire the token
* expires: new Date(Date.now() + 24 * 60 * 60 * 1000) cookie will expire in 1 day

****** magoose schema methods ********
* User Schema defines the User. i can attach the few methods on to the schema that is applicable for all users.
* In a schema, creating small functions/methods is useful because they let you add custom behavior to your model.
Main uses:
- Reusability – You can call the same logic in many places without rewriting it.
- Data-related logic – Keep logic tied to the data inside the model itself (e.g., formatting names, checking passwords).
- Cleaner controllers – Controllers stay simple, because the model handles its own work.
- Encapsulation – The schema “knows” how to work with its own data.

* Middleware is like a security guard, translator, and helper all in one — it checks, changes, or stops requests before they reach your actual route.
- req → the request object
- res → the response object
- next → a function you call to pass control to the next middleware

--------------------------------------
express router APIs session - 11
--------------------------------------
* logout code

res.clearCookie("token", null, { //clearing the cookie
    expires: new Date(Date.now()),
    httpOnly: true
}).send("Logout successful");// chaining here


--------------------------------------
logical DB queries session - 12
--------------------------------------
* enum : when you want to restrict the user with some values we can use ENUM datatype.
* schema pre : pre is function on schema of middleware. 

* how to put index in database
  - if we create index in database, query will be optimised.
  - mongo db automaticaly create index to optimize the query for unique: true coloumn.
  - either set (unique: true or index: true) to any coloumn you want.
  - compound index : 
    - compound index, 1 means asc order, -1 means desc order
    - connectionRequestSchema.index({fromUserId: 1, toUserId: 1}, {unique: true});
